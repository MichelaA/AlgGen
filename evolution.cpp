/***************************************************************************
 *   Copyright (C) 2008 by miki   *
 *   michela.antonelli@iet.unipi.it   *
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 *   This program is distributed in the hope that it will be useful,       *
 *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
 *   GNU General Public License for more details.                          *
 *                                                                         *
 *   You should have received a copy of the GNU General Public License     *
 *   along with this program; if not, write to the                         *
 *   Free Software Foundation, Inc.,                                       *
 *   59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *
 ***************************************************************************/
#include "evolution.h"

#include <fstream>
#include <cstring>

//extern int numpieces;


evolution::evolution():fis(numVar)
{ }

evolution::~evolution()
{ }

/******************************************************************
*******************************************************************
Inizializes the chromosome population with size element
	- chrom vector of chromosomes to be inizializes (also the memory space)
    - size  dimension of the population
******************************************************************
*******************************************************************/

void evolution::inizializePop(chromosome* chrom,int size)
{
     for (int i=0;i<size;i++)
		chrom[i].inizialize(fis);
}



/******************************************************************
*******************************************************************
Generates two offspring crossing all the chromosome part
	-	p0 first parent to be crossed
    -	p1 second parent to be crossed
	-	f0 first offspring generated by crossover
	-	f1 second offspring generated by crossover
 	-	MutProbAtt returns the value of the RB mutation probability (it depends if the RB crossover is applied or not (mutProbAtt=1) )
*****************************************0 1 7 10 11 13 14 16 18 19 20 dim_arc:7
940 182 202.22 -542.875 232.911 182 30 1 7 10 11 13 14 16 18 19 20 dim_arc:7*************************
*******************************************************************/
void evolution::crossover(chromosome& p0, chromosome& p1, chromosome& f0, chromosome& f1, double& MutProbAtt)
{
	if (Rand()< crossProb)
	{	RBcross++;
		if (TYPE==0)
			crossRB(p0,p1,f0,f1);		//crossover for the RB
		else
			crossWM(p0,p1,f0,f1);		//crossover for the RB
		MutProbAtt=mutProbTun;

		/*if (TuningPW)
			CruceBLXPW(p0,p1,f0,f1);*/
	}
	else
		//MutProbAtt=mutProb;
		MutProbAtt=1;
	if (ProbVarPartion!=0 && (Rand()<probCrossPart)) //crossover partition
		crossPart(p0,p1,f0,f1);
		//(p0.getRealPart(),p1.getRealPart(),f0.getRealPart(),f1.getRealPart());

	if (TuningPW && (Rand()<probCrossTun)) //crossover on the PW tuning
		CruceBLXPW(p0,p1,f0,f1);
}


/******************************************************************
*******************************************************************
Permforms the mutation operation
	-	 m return the muteted chromosome
    -	MutProbAtt RB mutation probability
	-	MutProbGRAtt Granularity mutation probability
******************************************************************
*******************************************************************/
void evolution::mutation(chromosome& m,double MutProbAtt,double MutProbGRAtt)
{
	double ruota;
	int quanti;

	if (TYPE==0)
	{	if (Rand() < MutProbAtt)  			//RB mutation
		{	ruota=Rand();
			RBmut++;
			quanti=Randint(1,maxMut);
			if (ruota <pmAdd)				//addRule mutation
			{	for (int j=0;j<quanti;j++)
				m.addRule(fis);
			}
			else
			{	if (ruota < pmAdd+pmRem)	//remRule mutation
				for (int j=0;j<quanti;j++)
						m.remRule();
				else	//modRule mutation
					for (int j=0;j<quanti;j++)
						m.modRule();
			}
		}
	}
	else
	{	MutProbAtt=mutProbTun;
		m.mutSelection(MutProbAtt);
	}   //end RB mutation


	if (ProbVarPartion && (Rand()<MutProbGRAtt))  //partition mutation
		m.MutacionGR();

	if (TuningPW && (Rand()<mutProbTun)) //PW tuning mutation
	{	m.MutacionPW(); DBmut++;}
}


void evolution::save(chromosome* appo,chromosome* pop,int dim, int num)
{
  savestep(appo ,dim,num,"Nd");	//scrivi soluzioni
  savestep(pop,dim,num,"NdRid");
}


void evolution::write(chromosome* appo,int dim,char* str)
{
	if (CLASSIFICATION)
		WriteResults(str,1-appo[0].getObjTot(5),1-*appo[0].ECM(fis,inOutTs,numPatterTs,true),appo[0].getNumRule(),appo[0].getComp());
	else
		WriteResults(str,appo[0].getObjTot(5),*appo[0].ECM(fis,inOutTs,numPatterTs,true),appo[0].getNumRule(),appo[0].getComp());
  saveresults(appo,dim);

}



/******************************************************************
*******************************************************************
Save the results of the population on files
     -  chrom vector of chromosomes to be saved
    -	popsize dimension of the population
	- 	conc if equal to 1 save the results of the concrete RB
		otherwise save the results of the virtual RB
******************************************************************
*******************************************************************/
void evolution::saveresults(chromosome* chrom, int popsize)
{
	fstream fpObj,fpM, fpGR, fpT;
	double* Errtst=0;
	int realNumRule;
	unsigned** rule;

	int ingressi=numVar;
	if (CLASSIFICATION)
		ingressi--;

	if (!ProbVarPartion)
	{	fpObj.open("NoDomV.txt",ios::out | ios::app);	//Containes for each solution in the pareto a row with the complexity, the training MSE,
		fpM.open("myMatV.txt",ios::out | ios::app);  	//Containes for each solution in the pareto the virtual RB
		fpT.open("TunV.txt",ios::out | ios::app);
		fpGR.open("GranV.txt",ios::out | ios::app);
	}
	else							//the integrity, the test MSE, the concrete and the virtual number of rules and the actual
	{	fpObj.open("NoDomC.txt",ios::out | ios::app);						//number of variable used
		fpM.open("myMatC.txt",ios::out | ios::app);  	//Containes for each solution in the pareto the virtual RB  	//Containes for each solution in the pareto the virtual RB
		fpT.open("TunC.txt",ios::out | ios::app);
		fpGR.open("GranC.txt",ios::out | ios::app); 		//Containes for each solution in the pareto the granularity of each variable
	}

	if (!fpObj || !fpM || !fpT || !fpGR)
	{	printf("Error opening file\n");
       	exit(1);
    }

	for (int i=0;i<6;i++)
	{	fpObj<<"0 ";
		fpT<<"0 ";
		fpM<<"0 ";
		fpGR<<"0 ";
	}

	int numR;

	int* appopart;

	float* pieces;
	//int objectives;
	double* d=0;
	unsigned** matAppo=0;
	gen* vettI;

	if (ProbVarPartion)
	{	matAppo=new unsigned*[maxRule];
		for (int i=0;i<maxRule;i++)
			matAppo[i]=new unsigned[numVar];
	}

	for (int i=0;i<popsize;i++)
	{
		fpObj<<endl;
		fpT<<endl;
		fpM<<endl<<i+1<<')'<<endl;
		fpGR<<endl;

		//objectives=chrom[i].getSizeObjTot();
		vettI=chrom[i].getVettR();

		Errtst=chrom[i].ECM(fis,inOutTs,numPatterTs,true);
		double comp=chrom[i].getComp();

		rule=chrom[i].getMatR();

		if (ProbVarPartion)
		{	for (int k=0;k<chrom[i].getNumRule();k++)
				for (int j=0;j<numVar;j++)
					matAppo[k][j]=rule[k][j];
			chrom[i].convertimat(matAppo,fis);
			realNumRule=chrom[i].deleteDup(matAppo,chrom[i].getNumRule());
			rule=matAppo;
			numR=realNumRule;
		}
		else
			numR=chrom[i].getNumRule();

		int numFeat=chrom[i].getNumFeat();

		for (int k=0;k<numR;k++)
		{	for(int j=0;j<numVar;j++)
				fpM<<rule[k][j]<<'\t';
			fpM<<endl;
		}
		for (int k=0;k<maxRule;k++)
		{	fpM<<vettI[k].index<<" ant: ";
			for(int j=0;j<numVar-1;j++)
				fpM<<vettI[k].vectAnt[j]<<' ';
					fpM<<endl;
		}
		if (CLASSIFICATION)
		{	double* pesi=chrom[i].getPesi();
			for (int k=0;k<numR;k++)
				fpM<<pesi[k]<<' ';
			fpM<<endl;
		}

		//max=objectives;
		int n=chrom[i].getRealNumRule();

		if (CLASSIFICATION)
			fpObj<<comp<<' '<<chrom[i].getObjTot(1)<<' '<<n<<' '<<chrom[i].getObjTot(3)<<' '<<numFeat<<' '<<1-chrom[i].getObjTot(5)<<' '<<1-Errtst[0]<<' ';
		else
			fpObj<<comp<<' '<<chrom[i].getObjTot(1)<<' '<<n<<' '<<chrom[i].getObjTot(3)<<' '<<numFeat<<' '<<chrom[i].getObjTot(5)<<' '<<Errtst[0]<<' ';


		if (ProbVarPartion!=0)
		{	appopart=chrom[i].getRealPart();
			for (int j=0;j<numVar;j++)
			{	fpGR<<appopart[j]<<' ';
				fpObj<<appopart[j]<<' ';
			}
		}

		for (int j=0;j<ingressi;j++)
		{	if (TuningPW!=0)
			{	pieces=chrom[i].getPwLT(j);

				for (int k=0;k<numParts[j]-2;k++)
				{	fpT<<pieces[k]<<' ';
					fpObj<<pieces[k]<<' ';
				}
			}
		}

	}

	if (ProbVarPartion)
	{	for (int k=0;k<maxRule;k++)
			delete[] matAppo[k];
		delete[] matAppo;
	}
	delete[] Errtst;


	fpObj<<endl;
	fpM<<endl;
	fpGR<<endl;
	fpT<<endl;
}




/******************************************************************
*******************************************************************
Print the solution with best accuracy
	-	arc0 vchromosome with the best accuracy
    -	it number of iteration
	-	archlenght archive dimension
*******************************************************************
*******************************************************************/
void evolution::stampaBest(chromosome& arc0,int it,int arclength)
{
	double* Errtst=arc0.ECM(fis,inOutTs,numPatterTs,true);
	int numR=arc0.getRealNumRule();
	int numFeat=arc0.getNumFeat();
	double comp=arc0.getComp();

	cout<<it<<' ';
	if (CLASSIFICATION)
		cout<<comp<<' '<<arc0.getObjTot(1)<<' '<<numR<<' '<<arc0.getObjTot(3)<<' '<<numFeat<<' '<<1-arc0.getObjTot(5)<<' '<<1-Errtst[0]<<' ';
	else
		cout<<comp<<' '<<arc0.getObjTot(1)<<' '<<numR<<' '<<arc0.getObjTot(3)<<' '<<numFeat<<' '<<arc0.getObjTot(5)<<' '<<Errtst[0]<<' ';
	cout<<"dim_arc:"<<arclength<<endl;
	delete[] Errtst;
}


/******************************************************************
*******************************************************************
Save the population after numEval evaluationed
    -	popsize dimension of the population
	-	numEval number of evaluation
*******************************************************************
*******************************************************************/

void evolution::savestep(chromosome* chrom, int popsize,int numEval,char* nome)
{

	//int noZero; //, realNumRule;
	char numst[100];
	char nomefile[100]="Nd";
	char nomefileGr[100]="Gr";
	char nomefileTu[100]="Tu";
	char nomefileMat[100]="Mat";
	fstream fpObj,fpM, fpGR, fpT;
	//double app;
	//unsigned** rule;
	double* Errtst=0;
//	int dimensione;

	int ingressi=numVar;
	if (CLASSIFICATION)
		ingressi--;

	strcpy(nomefile,nome);
	sprintf(numst,"%i",numEval);
	strcat(nomefile,numst);
	strcat(nomefileGr,numst);
	strcat(nomefileTu,numst);
	strcat(nomefileMat,numst);


	fpObj.open(nomefile,ios::out | ios::app);

	if (!fpObj)
	{	printf("Error opening file\n");
       	exit(1);
    }
	for (int i=0;i<6;i++)
		fpObj<<"0 ";


	int* appopart;
	float* pieces;
	double *d=0;
	//unsigned** matAppo;
	int numR;
	for (int i=0;i<popsize;i++)
	{	fpObj<<endl;

		Errtst=chrom[i].ECM(fis,inOutTs,numPatterTs,true);
		double comp=chrom[i].getComp();
		numR=chrom[i].getRealNumRule();
		int numFeat=chrom[i].getNumFeat();
		appopart=chrom[i].getRealPart();
		if (CLASSIFICATION)
			fpObj<<comp<<' '<<chrom[i].getObjTot(1)<<' '<<numR<<' '<<chrom[i].getObjTot(3)<<' '<<numFeat<<' '<<1-chrom[i].getObjTot(5)<<' '<<1-Errtst[0]<<' ';
		else
			fpObj<<comp<<' '<<chrom[i].getObjTot(1)<<' '<<numR<<' '<<chrom[i].getObjTot(3)<<' '<<numFeat<<' '<<chrom[i].getObjTot(5)<<' '<<Errtst[0]<<' ';
		if (ProbVarPartion!=0)
			for (int j=0;j<numVar;j++)
				fpObj<<appopart[j]<<' ';

		for (int j=0;j<ingressi;j++)
		{	if (TuningPW!=0)
			{	pieces=chrom[i].getPwLT(j);
				for (int k=0;k<numParts[j]-2;k++)
					fpObj<<pieces[k]<<' ';
			}
		}
	}

	fpObj<<endl;
	delete[] Errtst;
}


/******************************************************************
*******************************************************************
Sort the chromosome population by ascendent accuracy
    -	chrom population of chromosomes
	-	dimPop population dimension
*******************************************************************
*******************************************************************/
void evolution::ordinaPopChrom(chromosome* chrom,int dimPop)
{    qsort(chrom, dimPop, sizeof(chromosome),&compareChrom);
}






/*
 * evolution.h
 *
 *  Created on: May 20, 2010
 *      Author: miki
 */

#ifndef EVOLUTION_H_
#define EVOLUTION_H_

/***************************************************************************
 *   Copyright (C) 2008 by miki   *
 *   michela.antonelli@iet.unipi.it   *
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 *   This program is distributed in the hope that it will be useful,       *
 *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
 *   GNU General Public License for more details.                          *
 *                                                                         *
 *   You should have received a copy of the GNU General Public License     *
 *   along with this program; if not, write to the                         *
 *   Free Software Foundation, Inc.,                                       *
 *   59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *
 ***************************************************************************/

#include "chromosome.h"
#include "supportchrom.h"
# define INF 1.0e14


/**
* Class base for each evolutionary algorithm. Containes the common functions to inizialize a population, perform mutation and crossover operators and to save results
*/


class evolution
{
protected:
	int RBcross;
	int DBmut;
	int RBmut;

	frbs fis;		///< MFRBS used for evaluating chormosomes
	int dimMatWM;   //WM matrix dimension (if TYPE=1)
	unsigned int** matWM; //WM matrix (if TYPE=1)
/**
 	*  \param chrom vector of chromosomes to be inizializes (also the memory space)
    *  \param size  dimension of the population
*/
	void inizializePop(chromosome* chrom,int size); ///< Inizializes the chromosome population with size element

public:

	evolution();
	~evolution();

/**
 	*  \param p0 first parent to be crossed
    *  \param p1 second parent to be crossed
	*  \param f0 first offspring generated by crossover
	*  \param f1 second offspring generated by crossover
 	*  \param MutProbAtt return the value of the RB mutation probability (it depends if the RB crossover is applied or not (mutProbAtt=1) )
*/
	void crossover(chromosome& p0, chromosome& p1, chromosome& f0, chromosome& f1, double& MutProbAtt); ///< Performs the crossover operator



/**
 	*  \param m return the muteted chromosome
    *  \param MutProbAtt RB mutation probability
	*  \param MutProbGRAtt Granularity mutation probability
	*
*/
	void mutation(chromosome& m,double MutProbAtt,double MutProbGRAtt); ///< permforms the mutation operations


	int getNumRule(chromosome chrom[], int index){ return chrom[index].getNumRule();} ///< Returns the number of rules of the index-th chromosome
	double getObjAlg(chromosome chrom[], int index, int num){return chrom[index].getObjAlg(num);} ///< Returns the num-th objective of the index-th chromosome
	double getObjTot(chromosome chrom[], int index, int num){return chrom[index].getObjTot(num);}
	double getECM_ts(chromosome chrom[], int index){ return *chrom[index].ECM(fis,inOutTs,numPatterTs,true);} ///< Returns the error on the testset of the index-th chromosome

	double getECM_ts(int index, frbs& fis, chromosome* arc,bool conc){return *arc[index].ECM(fis,inOutTs,numPatterTs,true);}

/**
 	*  \param chrom vector of chromosomes to be saved
    *  \param popsize dimension of the population
 	*  \param conc if equal to 1 save the results of the concrete RB  otherwise save the results of the virtual RB
	*
*/
	void saveresults(chromosome* chrom, int popsize);  ///< Save the results of the population on files

	void save(chromosome* appo,chromosome* pop,int dim, int num);

	void write(chromosome* appo,int dim,char* str);


/**
 	*  \param arc0 chromosome with the best accuracy
    *  \param it number of iteration
	*  \param arclength archive dimension
	*  \param conc if equal to 1 save the results of the concrete RB  otherwise save the results of the virtual RB
	*
*/
    void stampaBest(chromosome& arc0,int it,int arclength); ///< Print the solution with best accuracy


/**
 	*  \param chrom vector of chromosomes to be saved
    *  \param popsize dimension of the population
	*  \param conc if equal to 1 save the results of the concrete RB  otherwise save the results of the virtual RB
	*  \param numEval number of evaluation
	*
*/
void savestep(chromosome* chrom, int popsize,int numEval,char*); ///< Save the population after numEval evaluation


/**
	*  \param chrom population of chromosomes
    *  \param dimPop dimension of the population
*/
void ordinaPopChrom(chromosome* chrom,int dimPop); ///< Sort the chromosome population by ascendent accuracy

};

#endif /* EVOLUTION_H_ */
